#!/usr/bin/env python
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

"""
Wrapper around Phabricator's `arc` cli to support submission of a series of commits.

Goals:
- must only use standard libraries
- must be a single file for easy deployment
- should work on python 2.7 and python 3.5+
"""

import ConfigParser
import argparse
import calendar
import datetime
import errno
import json
import logging
import os
import re
import stat
import subprocess
import sys
import tempfile
import termios
import time
import traceback
import tty
import urllib2

# MVP
# TODO unit tests

# v1.0
# TODO windows
# TODO Git support
# TODO python3

# Known Issues
# - reordering, folding, etc commits doesn't result in the stack being updated
#   correctly on phabricator, or may outright fail due to dependency loops.
#   to address this we'll need to talk to phabricator directly to query the current
#   stack, and clear dependencies prior to calling arc. we'd probably also have to
#   abandon revisions that are no longer part of the stack.


# Environment Vars

DEBUG = bool(os.getenv("DEBUG"))
IS_DEV = bool(os.getenv("IS_DEV"))
HAS_ANSI = (
    (hasattr(sys.stdout, "isatty") and sys.stdout.isatty())
    or os.getenv("TERM", "") == "ANSI"
    or os.getenv("PYCHARM_HOSTED", "") == "1"
)
SELF_FILE = os.getenv("UPDATE_FILE") if os.getenv("UPDATE_FILE") else __file__

# Constants and Globals

logger = logging.getLogger("review")
config = None

# Where to direct people when `arc` isn't installed.
GUIDE_URL = (
    "http://moz-conduit.readthedocs.io/en/latest/phabricator-user.html#quick-start"
)

# Auto-update
UPDATE_REPO = "globau/arc-review"
UPDATE_FREQUENCY = 72  # hours

# URL to post to.
PHABIRCATOR_PROD_URL = "https://phabricator.services.mozilla.com/"
PHABIRCATOR_DEV_URL = "https://phabricator-dev.allizom.org/"
PHABIRCATOR_URL = PHABIRCATOR_DEV_URL if IS_DEV else PHABIRCATOR_PROD_URL

# arc related consts.
ARC = ["arc"]
ARC_COMMIT_DESC_TEMPLATE = """
{summary}

Summary:
{body}

Test Plan:

{depends_on}

Reviewers: {reviewers}

Subscribers:

Bug #: {bug_id}
""".strip()
ARC_REV_URL_RE = re.compile(r"^\s*Revision URI: (http.+)$", flags=re.MULTILINE)
ARC_DIFF_REV_RE = re.compile(
    r"^\s*Differential Revision:\s*https://.+/D(\d+)\s*$", flags=re.MULTILINE
)

# If a commit body matches **all** of these, reject it.  This is to avoid the
# necessity to merge arc-style fields across an existing commit description
# and what we need to set.
ARC_REJECT_RE_LIST = [
    re.compile(r"^Summary:", flags=re.MULTILINE),
    re.compile(r"^Reviewers:", flags=re.MULTILINE),
]

# Bug and review regexs (from vct's commitparser)
BUG_ID_RE = re.compile(r"(?:(?:bug|b=)(?:\s*)(\d+)(?=\b))", flags=re.IGNORECASE)
LIST = r"[;,\/\\]\s*"
LIST_RE = re.compile(LIST)
IRC_NICK = (
    r"[a-zA-Z0-9\-\_!]+"
)  # Note this includes !, which is different from commitparser
REVIEWERS_RE = re.compile(
    r"([\s(.\[;,])(r[=?])("
    + IRC_NICK
    + r"(?:"
    + LIST
    + r"(?![a-z0-9.\-]+[=?])"
    + IRC_NICK
    + r")*)?"
)
R_SPECIFIER_RE = re.compile(r"\br[=?]")


#
# Utilities
#


def which(filename):
    # backport of shutil.which from py3
    seen = set()
    for path in os.environ.get("PATH", os.defpath).split(os.pathsep):
        norm_path = os.path.normcase(path)
        if norm_path not in seen:
            seen.add(norm_path)
            fn = os.path.join(path, filename)
            if (
                os.path.exists(fn)
                and os.access(fn, os.F_OK | os.X_OK)
                and not os.path.isdir(fn)
            ):
                return fn
    return None


def shell_quote(s):
    # backport of shutil.quote from py3
    # used for debugging output only
    _find_unsafe = re.compile(r"[^\w@%+=:,./-]").search
    if not s:
        return "''"
    if _find_unsafe(s) is None:
        return s
    return "'" + s.replace("'", "'\"'\"'").replace("\n", "\\n") + "'"


def parse_zulu_time(timestamp):
    """Parse YYYY-MM-DDTHH:mm:SSZ date string, return as epoch seconds in local tz."""
    return calendar.timegm(time.strptime(timestamp, "%Y-%m-%dT%H:%M:%SZ"))


def check_call(command, *args):
    # wrapper around subprocess.check_call with debug output
    logger.debug("$ %s" % " ".join(shell_quote(s) for s in command))
    subprocess.check_call(command, *args)


def check_output(command, split=True, never_log=False):
    # wrapper around subprocess.check_output with debug output and splitting
    logger.debug("$ %s" % " ".join(shell_quote(s) for s in command))
    try:
        output = subprocess.check_output(command).rstrip()
    except subprocess.CalledProcessError as e:
        logger.debug(e.output)
        raise Exception("command '%s' failed to complete successfully" % command[0])
    if output and not never_log:
        logger.debug(output)
    return output.splitlines() if split else output


def prompt(question, options):
    if HAS_ANSI:
        question = "\033[33m%s\033[0m" % question
    options[0] = options[0].upper()
    sys.stdout.write("%s (%s)? " % (question, "/".join(options)))
    sys.stdout.flush()

    res = ""
    old_term_attrs = None
    fd = sys.stdout.fileno()
    default = options[0][0].lower()
    options = {o[0].lower(): o for o in options}
    try:
        old_term_attrs = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
        except termios.error:
            pass
        while res not in options:
            res = sys.stdin.read(1).lower()
            if res == chr(13):
                res = default
            elif res == chr(3) or res == chr(27):
                sys.exit(1)
    except termios.error:
        while res not in options:
            res = sys.stdin.readline().strip().lower()
            if len(res) > 1:
                res = res[0]
    finally:
        if old_term_attrs:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_term_attrs)
            if res in options:
                print(options[res])
            else:
                print("^C")

    return options[res]


class Error(Exception):
    """Errors throw explictly by this script; won't generate a stack trace."""


#
# Configuration
#


class Config(object):
    def __init__(self):
        self._filename = os.path.join(os.path.expanduser("~"), ".review-config")
        self._config = ConfigParser.ConfigParser()
        self._config.read([self._filename])
        self.name = "~/.review-config"  # human-readable name

        self.no_ansi = self._get_boolean("ui", "no_ansi", False)
        self.auto_submit = self._get_boolean("submit", "auto_submit", False)
        self.always_blocking = self._get_boolean("submit", "always_blocking", False)
        self.warn_uncommitted = self._get_boolean("submit", "warn_uncommitted", True)
        self.updater_last_check = self._get_int("updater", "last_check", 0)

        if not os.path.exists(self._filename):
            self.write()

    def _get_boolean(self, section, option, default):
        try:
            value = self._config.getboolean(section, option)
            logger.debug("read config %s.%s: %s" % (section, option, value))
            return value
        except (ValueError, ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            logger.debug("using default config %s.%s: %s" % (section, option, default))
            return default

    def _get_int(self, section, option, default):
        try:
            value = self._config.getint(section, option)
            logger.debug("read config %s.%s: %s" % (section, option, value))
            return value
        except (ValueError, ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            logger.debug("using default config %s.%s: %s" % (section, option, default))
            return default

    def write(self):
        if os.path.exists(self._filename):
            logger.debug("updating %s" % self._filename)

            if not self._config.has_section("submit"):
                self._config.add_section("submit")
            self._config.set("submit", "auto_submit", self.auto_submit)

            if not self._config.has_section("updater"):
                self._config.add_section("updater")
            self._config.set("updater", "last_check", self.updater_last_check)

        else:
            logger.debug("creating %s" % self._filename)

            self._config.add_section("ui")
            self._config.set("ui", "no_ansi", self.no_ansi)

            self._config.add_section("submit")
            self._config.set("submit", "auto_submit", self.auto_submit)
            self._config.set("submit", "always_blocking", self.always_blocking)
            self._config.set("submit", "warn_uncommitted", self.warn_uncommitted)

        with open(self._filename, "w") as f:
            self._config.write(f)


#
# Repository
#


def repo_from_args(args):
    if hasattr(args, "path") and args.path:
        repo_path = args.path

    else:
        # Walk parents to find repository root.
        repo_path = None
        path = os.path.abspath(os.getcwd())
        while True:
            if os.path.exists(os.path.join(path, ".hg")) or os.path.exists(
                os.path.join(path, ".git")
            ):
                if repo_path:
                    raise Error(
                        "Nested repositories are not supported:\n%s\n%s\n"
                        "Specify a path using --path" % (repo_path, path)
                    )
                repo_path = path
            if not os.path.split(path)[1]:
                break
            path = os.path.abspath(os.path.join(path, os.path.pardir))
        if not repo_path:
            raise Error(
                "Not a repository (or any of the parent directories): .hg / .git"
            )

    os.chdir(repo_path)

    repo = None
    try:
        repo = Mercurial(repo_path)
    except ValueError:
        pass
    if not repo:
        try:
            repo = Git(repo_path)
        except ValueError:
            pass
    if not repo:
        raise Error("Failed to find Repository class for %s" % repo_path)

    repo.set_args(args)
    return repo


class Repository(object):
    def __init__(self, path):
        self.path = path
        self.args = None

    def cleanup(self):
        """Perform any repo-related cleanup tasks."""

    def set_args(self, args):
        self.args = args

    def uncommitted(self):
        """Return a list of uncommitted files."""

    def commit_stack(self):
        """Return list of commits - dicts with the following keys:
            name            human readable identifier of commit (eg. short sha)
            node            sha/hash
            summary         first line of commit description (unaltered)
            body            commit description, excluding first line
            summary-preview summary with bug-id and reviewer modifications
            bug-id          bmo bug-id
            bug-id-orig     original bug-id from commit desc
            reviewers       list of reviewers
            rev-id          phabricator revision id
        """

    def refresh_commit_stack(self, commits):
        """Update the stack following an altering change (eg rebase)."""
        augment_commits_from_body(commits)

    def checkout(self, node):
        """Checkout/Update to specified node."""

    def amend_commit(self, commit):
        """Amend commit description from `desc` field; return bool indicating if
        update was required."""

    def rebase_commit(self, source_commit, dest_commit):
        """Rebase."""

    def check_commits_for_submit(self, commits):
        """Validate the list of commits (from commit_stack) are ok to submit"""

        errors = []

        for commit in commits:
            commit_errors = []
            # TODO allow NOBUG in commit message (not in arg)
            # TODO be more relaxed if we're updating an existing rev?
            if not commit["bug-id"]:
                commit_errors.append("missing bug-id")

            if not commit["reviewers"]:
                commit_errors.append("missing reviewers")

            if has_arc_rejections(commit["body"]):
                commit_errors.append("contains arc fields")

            if commit_errors:
                errors.append(
                    "%s %s\n- %s"
                    % (commit["name"], commit["summary"], "\n- ".join(commit_errors))
                )

        if errors:
            raise Error("\n\n".join(errors))


#
# Mercurial
#


class Mercurial(Repository):
    def __init__(self, path):
        super(Mercurial, self).__init__(path)

        if not os.path.exists(os.path.join(path, ".hg")):
            raise ValueError("%s: not a hg repository" % path)
        if not which("hg"):
            raise Error("Failed to find 'hg' executable")

        logger.debug("found hg repo in %s" % path)

        self.hg = ["hg"]
        self.revset = None
        self.strip_nodes = []

        hg_config = {}
        for line in check_output(self.hg + ["config"], never_log=True):
            (name, value) = line.split("=", 1)
            name = name.strip()
            value = value.strip()
            if not name.startswith("extensions.") or not value.startswith("!"):
                hg_config[name] = value

        # Need to use the correct username.
        if "ui.username" not in hg_config:
            raise Error("ui.username is not configured in your hgrc")
        self.hg.extend(["--config", "ui.username=%s" % hg_config["ui.username"]])

        # Always need rebase.
        self.hg.extend(["--config", "extensions.rebase="])

        # Enable evolve if the user's currently using it.
        if "extensions.evolve" in hg_config:
            self.hg.extend(["--config", "extensions.evolve="])
            self.use_evolve = True

        # Otherwise just enable obsolescence markers, and remove the obsstore
        # when we're done.
        else:
            self.hg.extend(["--config", "experimental.evolution.createmarkers=true"])
            self.hg.extend(["--config", "extensions.strip="])
            self.use_evolve = False

        # Shorter graphs are nicer
        self.hg.extend(["--config", "experimental.graphshorten=true"])

        # Disable the user's hgrc file, to ensure we run without rogue extensions.
        os.environ["HGRCPATH"] = ""

    def cleanup(self):
        if not self.use_evolve:
            try:
                os.unlink(os.path.join(self.path, ".hg", "store", "obsstore"))
            except OSError as e:
                if e.errno != errno.ENOENT:
                    raise

        for node in self.strip_nodes:
            check_call(self.hg + ["strip", "--no-backup", node])

    def _hg_log(self, revset, split=True, select="node"):
        return check_output(
            self.hg + ["log", "-T", "{%s}\n" % select, "-r", revset], split=split
        )

    def uncommitted(self):
        return check_output(
            self.hg + ["status", "--unknown", "-T", "{path}\n"], split=True
        )

    def refresh_commit_stack(self, commits):
        """Update all commits to point to their superseded commit."""
        for commit in commits:
            hg_log = check_output(
                self.hg
                + ["log"]
                + ["-T", "{rev} {node}\n"]
                + ["--hidden"]
                + ["-r", "successors(%s) and not obsolete()" % commit["node"]]
            )
            if hg_log:
                # Not sure the best way to handle multiple successors, so just bail out.
                if len(hg_log) > 1:
                    raise Error(
                        "Multiple successors found for %s, unable to continue"
                        % commit["node"]
                    )

                (rev, node) = hg_log[0].split(" ", 1)
                commit["node"] = node
                commit["name"] = "%s:%s" % (rev, node[:12])

        self.revset = "%s::%s" % (commits[0]["node"], commits[-1]["node"])

        super(Mercurial, self).refresh_commit_stack(commits)

    def set_args(self, args):
        super(Mercurial, self).set_args(args)

        if self.args.start_rev == "(auto)":
            start = "ancestors(.) and not public() and not obsolete()"
        else:
            start = self.args.start_rev

        # resolve to nodes as that's nicer to read
        try:
            start = self._hg_log(start)[0]
        except IndexError:
            if self.args.start_rev == "(auto)":
                raise Error("Failed to find draft commits to submit")
            else:
                raise Error("Failed to start of commit range: %s" % self.args.start_rev)
        try:
            end = self._hg_log(self.args.end_rev)[0]
        except IndexError:
            raise Error("Failed to end of commit range: %s" % self.args.end_rev)

        self.revset = "%s::%s" % (start[:12], end[:12])

    def commit_stack(self):
        hg_log = check_output(
            self.hg
            + ["log", "-T", "{rev} {node} {desc|firstline}\n", "-r", self.revset]
        )

        commits = []
        for log_line in hg_log:
            (rev, node, summary) = log_line.split(" ", 2)
            commits.append(
                {
                    "name": "%s:%s" % (rev, node[:12]),
                    "node": node,
                    "summary": summary,
                    "summary-preview": summary,
                    "body": "",
                    "bug-id": None,
                    "reviewers": [],
                    "rev-id": None,
                }
            )
            body = check_output(self.hg + ["log", "-T", "{desc}", "-r", node])
            commits[-1]["body"] = "\n".join(body[1:]).rstrip()

        return commits

    def checkout(self, node):
        check_call(self.hg + ["update", "--quiet", node])

    def amend_commit(self, commit):
        current_body = "%s\n%s" % (commit["summary"], commit["body"])
        repo_body = check_output(
            self.hg + ["log", "-T", "{desc}", "-r", commit["node"]], split=False
        )
        if repo_body == current_body:
            logger.debug("not amending commit %s, unchanged" % commit["name"])
            return

        with tempfile.NamedTemporaryFile() as temp_f:
            temp_f.write(current_body)
            temp_f.flush()

            self.checkout(commit["node"])
            check_call(self.hg + ["commit", "--amend", "--logfile", temp_f.name])

        # If we don't have evolve we need to strip the commit, otherwise it will
        # "reappear" when we remove the obsstore.
        if not self.use_evolve:
            self.strip_nodes.append(commit["node"])

    def rebase_commit(self, source_commit, dest_commit):
        check_call(
            self.hg
            + ["rebase"]
            + ["--source", source_commit["node"]]
            + ["--dest", dest_commit["node"]]
        )

    def check_commits_for_submit(self, commits):
        nodes = [c["node"] for c in commits]

        # Merge base should be included in the revset
        ancestor = self._hg_log("ancestor(%s)" % self.revset, split=False)
        if ancestor not in nodes:
            raise Error(
                "Non-linear commit stack (common ancestor %s missing from stack)"
                % ancestor[:12]
            )

        # Merge base needs to have a public parent
        parent_phases = check_output(
            self.hg + ["log", "-T", "{phase} {node}\n", "-r", "parents(%s)" % ancestor]
        )
        for parent in parent_phases:
            (phase, node) = parent.split(" ", 1)
            if phase != "public":
                raise Error(
                    "%s is based off non-public commit %s" % (ancestor[:12], node[:12])
                )

        # Can't submit merge requests
        if self._hg_log("%s and merge()" % self.revset):
            raise Error("Commit stack contains a merge commit")

        for commit in commits:
            # Follow each branch on the DAG ensuring only one has our nodes
            children = self._hg_log("children(%s)" % commit["node"])
            found = False
            for child in children:
                descendants = self._hg_log(
                    "descendants(%s) and %s" % (child, self.revset)
                )
                if len(descendants):
                    if found:
                        raise Error("Non-linear commit stack")
                    found = True

        super(Mercurial, self).check_commits_for_submit(commits)


#
# Git
#


class Git(Repository):
    def __init__(self, path):
        super(Git, self).__init__(path)

        if not os.path.exists(os.path.join(path, ".git")):
            raise ValueError("%s: not a git repository" % path)
        if not which("git"):
            raise Error("Failed to find 'git' executable")
        # TODO draw the rest of the owl

        logger.debug("found git repo in %s" % path)

        raise NotImplementedError("git support is not yet implemented")


#
# Commit helpers
#


def parse_arc_diff_rev(body):
    m = ARC_DIFF_REV_RE.search(body)
    return m.group(1) if m else None


def parse_bugs(summary):
    return BUG_ID_RE.findall(summary)


def parse_reviewers(summary):
    reviewers = []
    for match in re.finditer(REVIEWERS_RE, summary):
        if not match.group(3):
            continue
        reviewers.extend(re.split(LIST_RE, match.group(3)))
    return reviewers


def has_arc_rejections(body):
    return all(r.search(body) for r in ARC_REJECT_RE_LIST)


def augment_commits_from_body(commits):
    """Extract metadata from commit body as fields.
    Adds: rev-id, bug-id, reviewers
    """

    for commit in commits:
        commit["rev-id"] = parse_arc_diff_rev(commit["body"])

        # bug-id
        bug_ids = parse_bugs(commit["summary"])
        if bug_ids:
            if len(bug_ids) > 1:
                logger.warning("Multiple bug-IDs found, using %s" % bug_ids[0])
            commit["bug-id"] = bug_ids[0]
        else:
            commit["bug-id"] = None
        if "bug-id-orig" not in commit:
            commit["bug-id-orig"] = commit["bug-id"]

        # reviewers
        commit["reviewers"] = parse_reviewers(commit["summary"])

    update_commit_summary_previews(commits)


def update_commit_summary_previews(commits):
    """Update summary-preview from commit metadata"""
    for commit in commits:
        # Reviewers.
        summary = replace_reviewers(commit["summary"], commit["reviewers"])

        # Bug-ID.
        if commit["bug-id"]:
            if BUG_ID_RE.search(summary):
                summary = BUG_ID_RE.sub("Bug %s" % commit["bug-id"], summary)
            else:
                summary = "Bug %s - %s" % (commit["bug-id"], summary)
        else:
            # This is likely to result in unappealing results.
            summary = BUG_ID_RE.sub("", summary)

        commit["summary-preview"] = summary


def replace_reviewers(commit_description, reviewers):
    """From vct's commitparser"""
    if not reviewers:
        reviewers_str = ""
    else:
        reviewers_str = "r=" + ",".join(reviewers)

    if commit_description == "":
        return reviewers_str

    commit_description = commit_description.splitlines()
    commit_summary = commit_description.pop(0)
    commit_description = "\n".join(commit_description)

    if not R_SPECIFIER_RE.search(commit_summary):
        commit_summary += " " + reviewers_str
    else:
        # replace the first r? with the reviewer list, and all subsequent
        # occurrences with a marker to mark the blocks we need to remove
        # later
        d = {"first": True}

        def replace_first_reviewer(matchobj):
            if R_SPECIFIER_RE.match(matchobj.group(2)):
                if d["first"]:
                    d["first"] = False
                    return matchobj.group(1) + reviewers_str
                else:
                    return "\0"
            else:
                return matchobj.group(0)

        commit_summary = re.sub(REVIEWERS_RE, replace_first_reviewer, commit_summary)

        # remove marker values as well as leading separators.  this allows us
        # to remove runs of multiple reviewers and retain the trailing
        # separator.
        commit_summary = re.sub(LIST + "\0", "", commit_summary)
        commit_summary = re.sub("\0", "", commit_summary)

    if commit_description == "":
        return commit_summary.strip()
    else:
        return commit_summary.strip() + "\n" + commit_description


def show_commit_stack(commits, show_rev_urls=False, show_warnings=False):
    """Log the commit stack in a human readable form."""
    for commit in commits:
        logger.info("%s %s" % (commit["name"], commit["summary-preview"]))
        if show_warnings:
            if commit["bug-id-orig"] and commit["bug-id"] != commit["bug-id-orig"]:
                logger.warning(
                    "!! Bug ID changed from %s to %s"
                    % (commit["bug-id-orig"], commit["bug-id"])
                )
        if show_rev_urls and commit["rev-id"]:
            logger.warning("-> %sD%s" % (PHABIRCATOR_URL, commit["rev-id"]))


def arc(args):
    arc_output = check_output(ARC + args, split=False)
    if logger.level != logging.DEBUG:
        logger.info(arc_output)
    return arc_output


def arc_message(template_vars):
    # Map `None` to an empty string
    for name in template_vars.keys():
        if template_vars[name] is None:
            template_vars[name] = ""

    # `depends_on` is optional
    if "depends_on" not in template_vars:
        template_vars["depends_on"] = ""

    message = ARC_COMMIT_DESC_TEMPLATE.format(**template_vars)
    logger.debug("--- arc message\n%s\n---" % message)
    return message


#
# "submit" Command
#


def update_commits_from_args(commits, args):
    # Build list of reviewers from args.
    reviewers = list(set(args.reviewer)) if args.reviewer else []
    blockers = list(set(args.blocker)) if args.blocker else []
    reviewers += ["%s!" % r.rstrip("!") for r in blockers]

    # Command args always overwrite commit desc.
    for commit in commits:
        if reviewers:
            commit["reviewers"] = reviewers
        if args.bug:
            commit["bug-id"] = args.bug

    # Otherwise honour config setting to always use blockers
    if not reviewers and config.always_blocking:
        for commit in commits:
            commit["reviewers"] = ["%s!" % r.rstrip("!") for r in commit["reviewers"]]

    update_commit_summary_previews(commits)


def submit(repo, args):
    if DEBUG or (hasattr(args, "trace") and args.trace):
        ARC.append("--trace")

    # Find and preview commits to submit
    commits = repo.commit_stack()
    if not commits:
        raise Error("Failed to find any commits to submit")
    logger.warning(
        "Submitting %s commit%s:" % (len(commits), "" if len(commits) == 1 else "s")
    )

    # Pre-Process to load metadata
    augment_commits_from_body(commits)
    update_commits_from_args(commits, args)

    # Validate commit stack is suitable for review
    show_commit_stack(commits, show_warnings=True)
    try:
        repo.check_commits_for_submit(commits)
    except Error as e:
        if not args.force:
            raise Error("Unable to submit commits:\n\n%s" % e)
        logger.error("Ignoring issues found with commits:\n\n%s" % e)

    # Show a warning if there are uncommitted files
    if config.warn_uncommitted:
        uncommitted = repo.uncommitted()
        if uncommitted:
            logger.warning(
                "Warning: found %s uncommitted file%s:"
                % (len(uncommitted), "" if len(uncommitted) == 1 else "s")
            )
            if len(uncommitted) <= 5:
                for filename in uncommitted:
                    logger.info("  %s" % filename)

    # Confirmation prompt
    if args.yes:
        pass
    elif config.auto_submit and not args.interactive:
        logger.info(
            "Automatically submitting (as per submit.auto_submit in %s)" % config.name
        )
    else:
        res = prompt(
            "Submit to Phabricator%s" % ("-dev" if IS_DEV else ""),
            ["Yes", "No", "Always"],
        )
        if res == "No":
            return
        if res == "Always":
            config.auto_submit = True
            config.write()

    # Process
    previous_commit = None
    rebase_onto = None
    for commit in commits:
        if rebase_onto:
            repo.rebase_commit(commit, rebase_onto)
            repo.refresh_commit_stack(commits)
            rebase_onto = None

        if commit["rev-id"]:
            logger.info("\nUpdating revision D%s:" % commit["rev-id"])
        else:
            logger.info("\nCreating new revision:")
        logger.info("%s %s" % (commit["name"], commit["summary-preview"]))
        repo.checkout(commit["node"])

        # Create arc-annotated commit description
        template_vars = dict(
            summary=commit["summary-preview"],
            body=commit["body"],
            reviewers=", ".join(commit["reviewers"]),
            bug_id=commit["bug-id"],
        )
        if previous_commit:
            template_vars["depends_on"] = "Depends on D%s" % previous_commit["rev-id"]
        message = arc_message(template_vars)

        # Run arc
        with tempfile.NamedTemporaryFile() as temp_f:
            temp_f.write(message)
            temp_f.flush()

            arc_args = (
                ["diff"]
                + ["--allow-untracked", "--no-amend", "--no-ansi"]
                + ["--message-file", temp_f.name]
            )
            if commit["rev-id"]:
                arc_args.extend(
                    ["--message", "Revision updated."] + ["--update", commit["rev-id"]]
                )
            else:
                arc_args.append("--create")

            arc_output = arc(arc_args)

        # Extract Revision URL
        m = ARC_REV_URL_RE.search(arc_output)
        if not m:
            raise Error("Failed to find 'Revision URL' in arc output")
        revision_url = m.group(1)

        # Append/replace div rev url to/in commit description
        body = commit["body"]
        body = ARC_DIFF_REV_RE.sub("", body).rstrip()
        if body:
            body += "\n"
        body += "\nDifferential Revision: %s" % revision_url

        if commit["summary-preview"] != commit["summary"] or body != commit["body"]:
            commit["summary"] = commit["summary-preview"]
            commit["body"] = body
            repo.amend_commit(commit)
            repo.refresh_commit_stack(commits)
            rebase_onto = commit

        previous_commit = commit

    logger.warning("\nCompleted")
    show_commit_stack(commits, show_rev_urls=True)


#
# Self-Updater
#


def get_self_release():
    releases_api_url = "https://api.github.com/repos/%s/releases/latest" % UPDATE_REPO
    logger.debug("fetching %s" % releases_api_url)

    try:
        release = json.load(urllib2.urlopen(releases_api_url))
    except (urllib2.HTTPError, urllib2.URLError) as e:
        raise Error("Failed to check for updates: %s" % e)
    except ValueError:
        raise Error("Malformed response from GitHub when checking for updates")
    logger.debug(release)

    published_at = parse_zulu_time(release["published_at"])
    try:
        m_time = os.path.getmtime(SELF_FILE)
    except OSError as e:
        if e.errno != errno.ENOENT:
            raise
        m_time = 0
    logger.debug("published_at: %s" % datetime.datetime.fromtimestamp(published_at))
    logger.debug("m_time: %s" % datetime.datetime.fromtimestamp(m_time))

    return dict(
        published_at=published_at,
        update_required=published_at > m_time,
        tag=str(release["tag_name"]),
    )


def check_self_update():
    if IS_DEV:
        logger.debug("skipping self-update check in development mode")
        return

    if time.time() - config.updater_last_check < UPDATE_FREQUENCY * 60 * 60:
        logger.debug("update check not required")
        return
    config.updater_last_check = int(time.time())
    config.write()

    release = get_self_release()
    if not release["update_required"]:
        return

    logger.warning("Version %s of `review` is now available" % release["tag"])
    logger.info("Run `review self-update` to update")


def self_update(args):
    release = get_self_release()

    if not release["update_required"] and not args.force:
        logger.warning("Update not required")
        return

    logger.warning("Updating to v%s" % release["tag"])

    url = "https://raw.githubusercontent.com/%s/%s/review" % (
        UPDATE_REPO,
        release["tag"],
    )
    logger.debug("updating '%s' from %s" % (SELF_FILE, url))
    try:
        gh = urllib2.urlopen(url)
        with open(SELF_FILE, "wb") as fh:
            fh.write(gh.read())
        os.chmod(SELF_FILE, stat.S_IRWXU)
    except (urllib2.HTTPError, urllib2.URLError) as e:
        raise Error("Failed to download update: %s" % e)

    logger.info("%s updated" % SELF_FILE)


#
# Main
#


def colour_logger(logger_method, colour_code):
    def wrapper(message, *args, **kwargs):
        return logger_method(
            "\033[%sm%s\033[0m" % (colour_code, message), *args, **kwargs
        )

    return wrapper


def init_logging():
    stdout_handler = logging.StreamHandler(sys.stdout)
    if HAS_ANSI:
        setattr(logger, "warning", colour_logger(getattr(logger, "warning"), "34"))
        setattr(logger, "error", colour_logger(getattr(logger, "error"), "31"))
    stdout_handler.setFormatter(logging.Formatter("%(message)s"))
    logger.addHandler(stdout_handler)
    logger.setLevel(logging.DEBUG if DEBUG else logging.INFO)


def parse_args():
    parser = argparse.ArgumentParser()
    commands = parser.add_subparsers(dest="command", metavar="COMMAND")
    commands.required = True

    # submit

    submit_parser = commands.add_parser(
        "submit", help="Submit commits(s) to Phabricator"
    )
    submit_parser.add_argument(
        "--path", "-p", help="Set path to repository (default: detected)"
    )
    submit_parser.add_argument(
        "--yes",
        "-y",
        action="store_true",
        help="Submit without confirmation (default: %s)" % config.auto_submit,
    )
    submit_parser.add_argument(
        "--interactive",
        "-i",
        action="store_true",
        help="Submit with confirmation (default: %s)" % (not config.auto_submit),
    )
    submit_parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force submission even if commit stack validation fails",
    )
    submit_parser.add_argument("--bug", "-b", help="Set Bug ID for all commits")
    submit_parser.add_argument(
        "--reviewer",
        "--reviewers",
        "-r",
        action="append",
        help="Set review(s) for all commits (default: from commit)",
    )
    submit_parser.add_argument(
        "--blocker",
        "--blocker",
        "-R",
        action="append",
        help="Set blocking review(s) for all commits (default: from commit)",
    )
    submit_parser.add_argument(
        "start_rev",
        nargs="?",
        default="(auto)",
        help="Start revision of range to submit (default: detected)",
    )
    submit_parser.add_argument(
        "end_rev",
        nargs="?",
        default=".",
        help="End revision of range to submit (default: current commit)",
    )

    # arc informs users to pass --trace for more output, so we need to accept it
    submit_parser.add_argument("--trace", action="store_true", help=argparse.SUPPRESS)

    submit_parser.set_defaults(func=submit, needs_repo=True)

    # self-update

    update_parser = commands.add_parser("self-update", help="Update review script")
    update_parser.add_argument(
        "--force", "-f", action="store_true", help="Force update even if not necessary"
    )
    update_parser.set_defaults(func=self_update, needs_repo=False)

    return parser.parse_args()


def main():
    global config, HAS_ANSI
    try:
        init_logging()
        config = Config()

        if config.no_ansi:
            HAS_ANSI = False

        if not which("arc"):
            raise Error(
                "Failed to find 'arc' on the system path.\n"
                "Please follow the Phabricator setup guide:\n"
                "%s" % GUIDE_URL
            )

        args = parse_args()

        if args.command != "self-update":
            check_self_update()

        if args.needs_repo:
            repo = repo_from_args(args)
            try:
                args.func(repo, args)
            finally:
                repo.cleanup()

        else:
            args.func(args)

    except KeyboardInterrupt:
        pass
    except Error as e:
        logger.error(e)
    except Exception as e:
        logger.error(
            traceback.format_exc() if DEBUG else "%s: %s" % (e.__class__.__name__, e)
        )


if __name__ == "__main__":
    main()

#!/usr/bin/env python
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

"""
Wrapper around Phabricator's `arc` cli to support submission of a series of commits.

Goals:
- must only use standard libraries
- must be a single file for easy deployment
- should work on python 2.7 and python 3.5+

Configuration:
`review` is configured via the following environmental variables:
NO_ANSI : disable ANSI output (default: auto-detected)
IS_DEV  : connect to phabricator dev instance (default: connect to production)
DEBUG   : enabled debugging output (default: disabled)

e.g. To enable debugging output on MacOS/Linux:
  $ DEBUG=1 review submit

`review` has an INI style configuration file to control defaults: ~/.review-config
This file will be created if it doesn't exist.

```
[submit]
auto_submit = False
always_blocking = False
```

submit.auto_submit: when true the confirmation prompt will be skipped.
submit.always_blocking: when true reviewers in commit descriptions will be marked as blocking.
                        note reviewers specified on the command line override this setting.
"""

import ConfigParser
import argparse
import logging
import os
import re
import subprocess
import sys
import tempfile
import termios
import tty

# TODO unit tests
# TODO unicode testing
# TODO python3
# TODO windows

# Environment Vars

DEBUG = bool(os.getenv("DEBUG"))
IS_DEV = bool(os.getenv("IS_DEV"))
HAS_ANSI = (
    (hasattr(sys.stdout, "isatty") and sys.stdout.isatty())
    or os.getenv("TERM", "") == "ANSI"
    or os.getenv("PYCHARM_HOSTED", "") == "1"
) and not os.getenv("NO_ANSI")

# Constants and Globals

logger = logging.getLogger("review")
config = None

# Where to direct people when `arc` isn't installed.
GUIDE_URL = (
    "http://moz-conduit.readthedocs.io/en/latest/phabricator-user.html#quick-start"
)

# URL to post to.
PHABIRCATOR_URL = (
    "https://phabricator-dev.allizom.org/"
    if IS_DEV
    else "https://phabricator.services.mozilla.com/"
)

# arc related consts.
ARC = ["arc"]
ARC_COMMIT_DESC_TEMPLATE = """
{summary}

Summary:
{body}

Test Plan:

{depends_on}

Reviewers: {reviewers}

Subscribers:

Bug #: {bug_id}
""".strip()
ARC_REV_URL_RE = re.compile(r"^\s*Revision URI: (http.+)$", flags=re.MULTILINE)
ARC_DIFF_REV_RE = re.compile(
    r"^\s*Differential Revision:\s*https://.+/D(\d+)$", flags=re.MULTILINE
)

# If a commit body matches all of these, reject it.  This is to avoid the
# necessity to merge arc-style fields across an existing commit description
# and what we need to set.
ARC_REJECT_RE_LIST = [
    re.compile(r"^Summary:", flags=re.MULTILINE),
    re.compile(r"^Reviewers:", flags=re.MULTILINE),
]

# Bug and review regexs (from vct's commitparser)
BUG_ID_RE = re.compile(r"(?:(?:bug|b=)(?:\s*)(\d+)(?=\b))", flags=re.IGNORECASE)
LIST = r"[;,\/\\]\s*"
LIST_RE = re.compile(LIST)
IRC_NICK = (
    r"[a-zA-Z0-9\-\_!]+"
)  # Note this includes !, which is different from commitparser
REVIEWERS_RE = re.compile(
    r"([\s(.\[;,])(r[=?])("
    + IRC_NICK
    + r"(?:"
    + LIST
    + r"(?![a-z0-9.\-]+[=?])"
    + IRC_NICK
    + r")*)?"
)
R_SPECIFIER_RE = re.compile(r"\br[=?]")

# Does this string look like a revision hash/number?
REV_RE = re.compile("^(?:[0-9a-f]{7,12,40}|\d+)$").search


#
# Utilities
#


def which(filename):
    # backport of shutil.which from py3
    seen = set()
    for path in os.environ.get("PATH", os.defpath).split(os.pathsep):
        norm_path = os.path.normcase(path)
        if norm_path not in seen:
            seen.add(norm_path)
            fn = os.path.join(path, filename)
            if (
                os.path.exists(fn)
                and os.access(fn, os.F_OK | os.X_OK)
                and not os.path.isdir(fn)
            ):
                return fn
    return None


def shell_quote(s):
    # backport of shutil.quote from py3
    _find_unsafe = re.compile(r"[^\w@%+=:,./-]").search
    if not s:
        return "''"
    if _find_unsafe(s) is None:
        return s
    return "'" + s.replace("'", "'\"'\"'").replace("\n", "\\n") + "'"


def check_call(command, *args):
    # wrapper around subprocess.check_call with debug output
    logger.debug("$ %s" % " ".join(shell_quote(s) for s in command))
    subprocess.check_call(command, *args)


def check_output(command, split=True):
    # wrapper around subprocess.check_output with debug output and splitting
    logger.debug("$ %s" % " ".join(shell_quote(s) for s in command))
    try:
        output = subprocess.check_output(command).rstrip()
    except subprocess.CalledProcessError as e:
        logger.debug(e.output)
        raise Exception("command '%s' failed to complete successfully" % command[0])
    if output:
        logger.debug(output)
    return output.splitlines() if split else output


def prompt(question, options):
    if HAS_ANSI:
        question = "\033[33m%s\033[0m" % question
    options[0] = options[0].upper()
    sys.stdout.write("%s (%s)? " % (question, "/".join(options)))
    sys.stdout.flush()

    res = ""
    old_term_attrs = None
    fd = sys.stdout.fileno()
    default = options[0][0].lower()
    options = {o[0].lower(): o for o in options}
    try:
        old_term_attrs = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
        except termios.error:
            pass
        while res not in options:
            res = sys.stdin.read(1).lower()
            if res == chr(13):
                res = default
            elif res == chr(3) or res == chr(27):
                sys.exit(1)
    except termios.error:
        while res not in options:
            res = sys.stdin.readline().strip().lower()
            if len(res) > 1:
                res = res[0]
    finally:
        if old_term_attrs:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_term_attrs)
            if res in options:
                print(options[res])
            else:
                print("^C")

    return options[res]


class ReviewError(Exception):
    """Errors throw explictly by this script, result in slightly different output."""


#
# Configuration
#


class Config(object):
    def __init__(self):
        self._filename = os.path.join(os.path.expanduser("~"), ".review-config")
        self._config = ConfigParser.ConfigParser()
        self._config.read([self._filename])

        self.auto_submit = self._get_boolean("submit", "auto_submit", False)
        self.always_blocking = self._get_boolean("submit", "always_blocking", False)

        if not os.path.exists(self._filename):
            self.write()

    def _get_boolean(self, section, option, default):
        try:
            value = self._config.getboolean(section, option)
            logger.debug("read config %s.%s: %s" % (section, option, value))
            return value
        except (ValueError, ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            logger.debug("using default config %s.%s: %s" % (section, option, default))
            return default

    def write(self):
        if os.path.exists(self._filename):
            logger.info("updating %s" % self._filename)
        else:
            logger.info("creating %s" % self._filename)

        if not self._config.has_section("submit"):
            self._config.add_section("submit")
        self._config.set("submit", "auto_submit", self.auto_submit)
        self._config.set("submit", "always_blocking", self.always_blocking)

        with open(self._filename, "w") as f:
            self._config.write(f)


#
# Repository
#


def find_repo_root():
    """Walk parents to find repository root."""
    # TODO add --path arg to override
    repo_root = None
    path = os.path.abspath(os.getcwd())
    while True:
        if os.path.exists(os.path.join(path, ".hg")) or os.path.exists(
            os.path.join(".git")
        ):
            if repo_root:
                raise ReviewError(
                    "Nested repositories are not supported:\n%s\n%s" % (repo_root, path)
                )
            repo_root = path
        if not os.path.split(path)[1]:
            break
        path = os.path.abspath(os.path.join(path, os.path.pardir))
    if not repo_root:
        raise ReviewError(
            "Not a repository (or any of the parent directories): .hg / .git"
        )
    return repo_root


def repo_from_root(path):
    try:
        return Mercurial(path)
    except ValueError:
        pass
    try:
        return Git(path)
    except ValueError:
        pass
    raise ReviewError("Failed to find Repository class for %s" % path)


class Repository(object):
    def __init__(self, path):
        self.path = path
        self.args = None

    def set_args(self, args):
        self.args = args

    def add_submit_arguments(self, parser):
        """Add vcs-specific args to the `submit` command."""

    def commit_stack(self):
        """Return list of { node, summary, body }."""

    def show_commit_stack(self, commits):
        """Log the commit stack in a human readable form."""

    def refresh_commit_stack(self, commits):
        """Update the stack following an altering change (eg rebase)."""

    def checkout(self, node):
        """Checkout/Update to specified node."""

    def amend_commit(self, commit):
        """Amend commit description from `desc` field; return bool indicating if update was required."""

    def rebase_commit(self, source_commit, dest_commit):
        """Rebase."""

    def check_commits_for_submit(self, commits):
        """Validate the list of commits (from commit_stack) are ok to submit"""

        errors = []

        for commit in commits:
            commit_errors = []
            # TODO treat bug-id the same as reviewers; update from args, validate if missing, no need for cross-check
            if not self.args.bug and not commit["bug-id"]:
                commit_errors.append("missing bug-id")
            if self.args.bug and commit["bug-id"] and self.args.bug != commit["bug-id"]:
                commit_errors.append(
                    "bug-id mismatch between command line (bug %s) and commit (bug %s)"
                    % (self.args.bug, commit["bug-id"])
                )

            if not commit["reviewers"]:
                commit_errors.append("missing reviewers")

            if all(r.search(commit["body"]) for r in ARC_REJECT_RE_LIST):
                commit_errors.append("contains arc fields")

            if commit_errors:
                errors.append(
                    "%s %s\n- %s"
                    % (commit["name"], commit["summary"], "\n- ".join(commit_errors))
                )

        if errors:
            raise ReviewError("Unable to submit commits:\n\n%s" % "\n\n".join(errors))


#
# Mercurial
#


class Mercurial(Repository):
    def __init__(self, path):
        super(Mercurial, self).__init__(path)

        if not os.path.exists(os.path.join(path, ".hg")):
            raise ValueError("%s: not a hg repository" % path)
        if not which("hg"):
            raise ReviewError("Failed to find 'hg' executable")

        logger.debug("found hg repo in %s" % path)

        self.hg = ["hg"]
        self.revset = None

        hg_config = {}
        for line in check_output(self.hg + ["config"]):
            (name, value) = line.split("=", 1)
            hg_config[name] = value

        # Need to use the correct username.
        if "ui.username" not in hg_config:
            raise ReviewError("ui.username is not configured in your hgrc")
        self.hg.extend(["--config", "ui.username=%s" % hg_config["ui.username"]])

        # Always need rebase.
        self.hg.extend(["--config", "extensions.rebase="])

        # TODO test without evolve
        # experimental.evolution.createmarkers=true
        # do the work, then delete the obs file

        # Enable evolve if the user's currently using it.
        if "extensions.evolve" in hg_config:
            self.hg.extend(["--config", "extensions.evolve="])

        # Shorter graphs are nicer
        self.hg.extend(["--config", "experimental.graphshorten=true"])

        # Disable the user's hgrc file, to ensure we run without rogue extensions.
        os.environ["HGRCPATH"] = ""

    def _hg_log(self, revset, split=True, select="node"):
        return check_output(
            self.hg + ["log", "-T", "{%s}\n" % select, "-r", revset], split=split
        )

    def refresh_commit_stack(self, commits):
        """Update all commits to point to their superseded commit."""
        for commit in commits:
            hg_log = check_output(
                self.hg
                + ["log"]
                + ["-T", "{rev} {node}\n"]
                + ["--hidden"]
                + ["-r", "successors(%s)" % commit["node"]],
                split=False,
            )
            if hg_log:
                (rev, node) = hg_log.split(" ", 1)
                commit["node"] = node
                commit["name"] = "%s:%s" % (rev, node[:12])

        augment_commits_from_body(commits)

        self.revset = "%s::%s" % (commits[0]["node"], commits[-1]["node"])

    def add_submit_arguments(self, parser):
        parser.add_argument(
            "start_rev",
            nargs="?",
            default="(auto)",
            help="Start revision of range to submit",
        )
        parser.add_argument(
            "end_rev", nargs="?", default=".", help="End revision of range to submit"
        )

    def set_args(self, args):
        super(Mercurial, self).set_args(args)

        if self.args.start_rev == "(auto)":
            self.args.start_rev = "children(last(public())) and (not obsolete())"

        # resolve to nodes as that's nicer to read
        try:
            start = self._hg_log(self.args.start_rev)[0]
        except IndexError:
            raise ReviewError(
                "Failed to start of commit range: %s" % self.args.start_rev
            )
        try:
            end = self._hg_log(self.args.end_rev)[0]
        except IndexError:
            raise ReviewError("Failed to end of commit rnage: %s" % self.args.end_rev)

        self.revset = "%s::%s" % (start[:12], end[:12])

    def commit_stack(self):
        hg_log = check_output(
            self.hg
            + ["log", "-T", "{rev} {node} {desc|firstline}\n", "-r", self.revset]
        )

        commits = []
        for log_line in hg_log:
            (rev, node, summary) = log_line.split(" ", 2)
            commits.append(
                dict(name="%s:%s" % (rev, node[:12]), node=node, summary=summary)
            )
            body = check_output(self.hg + ["log", "-T", "{desc}", "-r", node])
            if body:
                commits[-1]["body"] = ""
            else:
                commits[-1]["body"] = "\n".join(body[1:]).rstrip()

        return commits

    def show_commit_stack(self, commits):
        commit_dict = dict(map(lambda co: (co["node"], co), commits))
        log_output = check_output(
            self.hg
            + ["log", "-G"]
            + ["-T", "{node}\n"]
            + ["-r", "|".join([c["node"] for c in commits])]
        )
        log_rev_re = re.compile(r" ([a-f0-9]{40})$")
        for log_line in log_output:
            # Replace the commit's node with the full-formed summary
            m = log_rev_re.search(log_line)
            if m:
                rev = m.group(1)
                log_line = log_line.replace(rev, commit_dict[rev]["summary-preview"])
            logger.info(log_line)

    def checkout(self, node):
        check_call(self.hg + ["update", "--quiet", node])

    def amend_commit(self, commit):
        current_body = "%s\n%s" % (commit["summary"], commit["body"])
        repo_body = check_output(
            self.hg + ["log", "-T", "{desc}", "-r", commit["node"]], split=False
        )
        if repo_body == current_body:
            logger.debug("not amending commit %s, unchanged" % commit["name"])
            return

        with tempfile.NamedTemporaryFile() as temp_f:
            temp_f.write(current_body)
            temp_f.flush()

            self.checkout(commit["node"])
            check_call(self.hg + ["commit", "--amend", "--logfile", temp_f.name])

    def rebase_commit(self, source_commit, dest_commit):
        check_call(
            self.hg
            + [
                "rebase",
                "--source",
                source_commit["node"],
                "--dest",
                dest_commit["node"],
            ]
        )

    def check_commits_for_submit(self, commits):
        nodes = [c["node"] for c in commits]

        # TODO provide an override switch, to skip the potentially expensive or incorrect checks

        # Merge base should be included in the revset
        ancestor = self._hg_log("ancestor(%s)" % self.revset, split=False)
        if ancestor not in nodes:
            raise ReviewError(
                "Non-linear commit stack (common ancestor %s missing from stack)"
                % ancestor[:12]
            )

        # Merge base needs to have a public parent
        parent_phases = check_output(
            self.hg + ["log", "-T", "{phase} {node}\n", "-r", "parents(%s)" % ancestor]
        )
        for parent in parent_phases:
            (phase, node) = parent.split(" ", 1)
            if phase != "public":
                raise ReviewError(
                    "%s is based off non-public commit %s" % (ancestor[:12], node[:12])
                )

        # Can't submit merge requests
        if self._hg_log("%s and merge()" % self.revset):
            raise ReviewError("Commit stack contains a merge commit")

        for commit in commits:
            # Follow each branch on the DAG ensuring only one has our nodes
            children = self._hg_log("children(%s)" % commit["node"])
            found = False
            for child in children:
                descendants = self._hg_log(
                    "descendants(%s) and %s" % (child, self.revset)
                )
                if len(descendants):
                    if found:
                        raise ReviewError("Non-linear commit stack")
                    found = True

        super(Mercurial, self).check_commits_for_submit(commits)


#
# Git
#


class Git(Repository):
    def __init__(self, path):
        super(Git, self).__init__(path)

        if not os.path.exists(os.path.join(path, ".git")):
            raise ValueError("%s: not a git repository" % path)
        if not which("git"):
            raise ReviewError("Failed to find 'git' executable")
        # TODO cinnabar check
        # TODO draw the rest of the owl

        logger.debug("found git repo in %s" % path)


#
# Commit helpers
#


def augment_commits_from_body(commits):
    """Extract metadata from commit body as fields.
    Adds: rev-id, bug-id, reviewers
    """

    for commit in commits:
        m = ARC_DIFF_REV_RE.search(commit["body"])
        commit["rev-id"] = m.group(1) if m else None

        # bug-id
        bug_ids = BUG_ID_RE.findall(commit["summary"])
        if bug_ids:
            if len(bug_ids) > 1:
                logger.warning("Multiple bug-IDs found, using %s" % bug_ids[0])
            commit["bug-id"] = bug_ids[0]
        else:
            commit["bug-id"] = None

        # reviewers
        reviewers = []
        for match in re.finditer(REVIEWERS_RE, commit["summary"]):
            if not match.group(3):
                continue
            reviewers.extend(re.split(LIST_RE, match.group(3)))
        commit["reviewers"] = reviewers

        commit["summary-preview"] = replace_reviewers(commit["summary"], [])


def replace_reviewers(commit_description, reviewers):
    """From vct's commitparser"""
    if not reviewers:
        reviewers_str = ""
    else:
        reviewers_str = "r=" + ",".join(reviewers)

    if commit_description == "":
        return reviewers_str

    commit_description = commit_description.splitlines()
    commit_summary = commit_description.pop(0)
    commit_description = "\n".join(commit_description)

    if not R_SPECIFIER_RE.search(commit_summary):
        commit_summary += " " + reviewers_str
    else:
        # replace the first r? with the reviewer list, and all subsequent
        # occurrences with a marker to mark the blocks we need to remove
        # later
        d = {"first": True}

        def replace_first_reviewer(matchobj):
            if R_SPECIFIER_RE.match(matchobj.group(2)):
                if d["first"]:
                    d["first"] = False
                    return matchobj.group(1) + reviewers_str
                else:
                    return "\0"
            else:
                return matchobj.group(0)

        commit_summary = re.sub(REVIEWERS_RE, replace_first_reviewer, commit_summary)

        # remove marker values as well as leading separators.  this allows us
        # to remove runs of multiple reviewers and retain the trailing
        # separator.
        commit_summary = re.sub(LIST + "\0", "", commit_summary)
        commit_summary = re.sub("\0", "", commit_summary)

    if commit_description == "":
        return commit_summary.strip()
    else:
        return commit_summary.strip() + "\n" + commit_description


#
# "submit" Command
#


def update_commits_from_args(commits, args):
    # Build list of reviewers from args.
    reviewers = list(set(args.reviewer)) if args.reviewer else []
    blockers = list(set(args.blocker)) if args.blocker else []
    reviewers += ["%s!" % r.rstrip("!") for r in blockers]

    # Command args always overwrite commit desc.
    if reviewers:
        for commit in commits:
            commit["reviewers"] = reviewers

    # Otherwise honour config setting to always use blockers
    elif config.always_blocking:
        for commit in commits:
            commit["reviewers"] = ["%s!" % r.rstrip("!") for r in commit["reviewers"]]

    # Update commit summaries.
    for commit in commits:
        # Reviewers.
        summary = replace_reviewers(commit["summary"], commit["reviewers"])

        # Bug-ID.
        if not BUG_ID_RE.search(summary) and not commit["bug-id"] and args.bug:
            summary = "Bug %s - %s" % (args.bug, summary)

        commit["summary-preview"] = summary


def submit(repo, args):
    # Find and preview commits to submit
    commits = repo.commit_stack()
    if not commits:
        raise ReviewError("Failed to find any commits to submit")
    logger.warning(
        "Submitting %s commit%s:" % (len(commits), "" if len(commits) == 1 else "s")
    )

    # Pre-Process to load metadata
    augment_commits_from_body(commits)
    update_commits_from_args(commits, args)

    # Validate commit stack is suitable for review
    repo.show_commit_stack(commits)
    repo.check_commits_for_submit(commits)

    if not config.auto_submit:
        res = prompt("Submit to Phabricator", ["Yes", "No", "Always"])
        if res == "No":
            return
        if res == "Always":
            config.auto_submit = True
            config.write()

    # Process
    previous_commit = None
    rebase_onto = None
    for commit in commits:
        if rebase_onto:
            repo.rebase_commit(commit, rebase_onto)
            repo.refresh_commit_stack(commits)
            rebase_onto = None

        if commit["rev-id"]:
            logger.warning("Updating revision D%s:" % commit["rev-id"])
        else:
            logger.warning("Creating new revision:")
        logger.warning("%s %s" % (commit["name"], commit["summary-preview"]))
        repo.checkout(commit["node"])

        # Create arc-annotated commit description
        template_vars = dict(
            summary=commit["summary-preview"],
            body=commit["body"],
            reviewers=", ".join(commit["reviewers"]),
            bug_id=commit["bug-id"] if commit["bug-id"] else args.bug,  # TODO fixup
            depends_on="",
        )
        if previous_commit:
            template_vars["depends_on"] = "Depends on D%s" % previous_commit["rev-id"]
        arc_commit_desc = ARC_COMMIT_DESC_TEMPLATE.format(**template_vars)
        logger.debug("--- arc message\n%s\n---" % arc_commit_desc)

        # Run arc
        with tempfile.NamedTemporaryFile() as temp_f:
            temp_f.write(arc_commit_desc)
            temp_f.flush()

            arc_command = (
                ARC
                + ["diff"]
                + ["--allow-untracked", "--no-amend", "--no-ansi"]
                + ["--message-file", temp_f.name]
            )

            if commit["rev-id"]:
                arc_command.extend(
                    ["--message", "Revision updated."] + ["--update", commit["rev-id"]]
                )
            else:
                arc_command.append("--create")

            arc_output = check_output(arc_command, split=False)
            if logger.level != logging.DEBUG:
                logger.info(arc_output)

        # Extract Revision URL
        m = ARC_REV_URL_RE.search(arc_output)
        if not m:
            raise ReviewError("Failed to find 'Revision URL' in arc output")
        revision_url = m.group(1)

        # Append/replace div rev url to/in commit description
        body = commit["body"]
        body = ARC_DIFF_REV_RE.sub("", body).rstrip()
        if body:
            body += "\n\n"
        body += "Differential Revision: %s" % revision_url

        if commit["body"] != body:
            commit["body"] = body
            repo.amend_commit(commit)
            repo.refresh_commit_stack(commits)
            rebase_onto = commit

        previous_commit = commit


#
# Main
#


def colour_logger(logger_method, colour_code):
    def wrapper(message, *args, **kwargs):
        return logger_method(
            "\033[%sm%s\033[0m" % (colour_code, message), *args, **kwargs
        )

    return wrapper


def init_logging():
    stdout_handler = logging.StreamHandler(sys.stdout)
    if HAS_ANSI:
        setattr(logger, "warning", colour_logger(getattr(logger, "warning"), "34"))
        setattr(logger, "error", colour_logger(getattr(logger, "error"), "31"))
    stdout_handler.setFormatter(logging.Formatter("%(message)s"))
    logger.addHandler(stdout_handler)
    logger.setLevel(logging.DEBUG if DEBUG else logging.INFO)
    if not DEBUG:
        sys.tracebacklimit = 0


def parse_args(repo):
    parser = argparse.ArgumentParser()
    commands = parser.add_subparsers(dest="command")
    commands.required = True

    submit_parser = commands.add_parser(
        "submit", help="Submit commits(s) to Phabricator"
    )
    submit_parser.add_argument("--bug", "-b", help="Set Bug ID for all commits")
    submit_parser.add_argument(
        "--reviewer",
        "--reviewers",
        "-r",
        action="append",
        help="Set review(s) for all commits",
    )
    submit_parser.add_argument(
        "--blocker",
        "--blocker",
        "-R",
        action="append",
        help="Set blocking review(s) for all commits",
    )
    # arc informs users to pass --trace for more output, so we need to accept it
    submit_parser.add_argument("--trace", action="store_true", help=argparse.SUPPRESS)
    repo.add_submit_arguments(submit_parser)
    submit_parser.set_defaults(func=submit)

    return parser.parse_args()


def main():
    global config
    try:
        init_logging()
        config = Config()

        if not which("arc"):
            raise ReviewError(
                "Failed to find 'arc' on the system path.\n"
                "Please follow the Phabricator setup guide:\n"
                "%s" % GUIDE_URL
            )

        repo = repo_from_root(find_repo_root())
        args = parse_args(repo)

        if DEBUG or (hasattr(args, "trace") and args.trace):
            ARC.append("--trace")

        repo.set_args(args)
        args.func(repo, args)
    except KeyboardInterrupt:
        pass
    except ReviewError as e:
        if DEBUG:
            raise
        logger.error(e)
    except Exception as e:
        if DEBUG:
            raise
        logger.error("%s: %s" % (e.__class__.__name__, e))


# TODO check reordering
# TODO reordering and dep cycles


if __name__ == "__main__":
    main()
